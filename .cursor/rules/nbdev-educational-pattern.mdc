
# NBDev Educational Pattern for TinyTorch Modules

When working with module development files (`*_dev.py`), follow this educational structure:

## File Format
Use Jupytext percent format with NBDev directives:

```python
# ---
# jupyter:
#   jupytext:
#     text_representation:
#       extension: .py
#       format_name: percent
#       format_version: '1.3'
#       jupytext_version: 1.17.1
# ---

# %% [markdown]
"""
# Module X: Title - Brief Description

## Learning Objectives
- âœ… Build {core_concept} from scratch
- âœ… Use it with real data ({dataset_name})
- âœ… Understand {key_insight}
- âœ… Connect to production ML systems

Educational introduction and learning goals...
"""

# %%
#| default_exp core.component_name

# Setup and imports
import required_libraries
import matplotlib.pyplot as plt  # For visual feedback

# %% [markdown]
"""
## Step 1: Concept Explanation
Educational content explaining the concept...
"""

# %%
#| export
class ComponentName:
    """
    Component description.
    
    TODO: Student implementation instructions.
    
    APPROACH:
    1. Concrete first step with specific guidance
    2. Concrete second step with specific guidance
    3. Concrete third step with specific guidance
    
    EXAMPLE:
    Input: actual_data_example
    Expected: concrete_expected_output
    
    HINTS:
    - Helpful guidance without giving code
    - Systems thinking consideration
    - Real-world connection
    
    SYSTEMS THINKING:
    - Performance consideration
    - Scalability question
    - User experience aspect
    """
    def method(self):
        raise NotImplementedError("Student implementation required")

# %%
#| hide
#| export  
class ComponentName:
    """Complete implementation (hidden from students)."""
    def method(self):
        # Actual implementation
        pass

# %% [markdown]
"""
## ðŸ§ª Test Your Implementation
"""

# %%
# Test with real data
try:
    # Test student implementation
    result = ComponentName(real_data_example)
    print(f"âœ… Success: {result}")
except NotImplementedError:
    print("âš ï¸ Implement the class above first!")

# Visual feedback (development only - not exported)
def show_results(data):
    """Show visual confirmation of working code."""
    if not _should_show_plots():
        return
    plt.figure(figsize=(10, 6))
    # Visualization code
    plt.show()

if _should_show_plots():
    show_results(real_data)
```

## Key NBDev Directives

- `#| default_exp core.module` - Sets export destination in tinytorch package
- `#| export` - Marks code for export to package
- `#| hide` - Hides cell from students (instructor solution)
- `# %% [markdown]` - Markdown cells for explanations
- `# %%` - Code cells

## Educational Structure

### 1. **Conceptual Foundation** (REQUIRED)
Each module must start with clear conceptual explanations:

```markdown
## Step 1: What is [Concept]?

**Definition**: Clear, simple definition with examples
**Why it matters**: Real-world motivation and ML context
**How it works**: Intuitive explanation before math
**Visual examples**: Concrete examples, diagrams, analogies
**Connection**: How it builds on previous modules
```

### 2. **Guided Implementation** (REQUIRED)
Instead of just `raise NotImplementedError`, provide:

```python
def method(self):
    """
    TODO: Step-by-step implementation guide
    
    APPROACH:
    1. First, think about what this method should return
    2. Consider the data types and shapes involved
    3. Start with a simple case, then generalize
    
    EXAMPLE:
    Input: actual_data_example  # Real data, not synthetic
    Expected output: concrete_expected_output
    
    HINTS:
    - Use real data patterns, not synthetic examples
    - Consider edge cases that occur in production
    - Think about performance with large datasets
    - Include progress feedback for long operations
    
    SYSTEMS THINKING:
    - How does this scale with larger datasets?
    - What happens when network/disk is slow?
    - How do users know the operation is working?
    """
    # Step 1: [specific guidance]
    # Step 2: [specific guidance] 
    # Step 3: [specific guidance]
    raise NotImplementedError("Student implementation required")
```

### 3. **Real Data Usage** (REQUIRED)
All modules must use production datasets:

```python
# âœ… GOOD: Real data
dataset = CIFAR10Dataset('data/cifar10/', train=True, download=True)
image, label = dataset[0]
assert image.shape == (3, 32, 32)  # Real image dimensions

# âŒ BAD: Mock/synthetic data
dataset = MockDataset(size=100)  # Fake data
```

### 4. **Visual Feedback** (REQUIRED)
Include visual confirmation (development only):

```python
def show_data_samples(dataset, num_samples=8):
    """Show grid of actual data samples (development only)."""
    # NOT exported to package - development feedback only
    if not _should_show_plots():
        return
        
    fig, axes = plt.subplots(2, 4, figsize=(12, 6))
    for i in range(num_samples):
        image, label = dataset[i]
        # Show actual data with proper visualization
        axes[i//4, i%4].imshow(image.transpose(1, 2, 0))
        axes[i//4, i%4].set_title(f'Class: {label}')
    plt.show()
```

### 5. **Progress Feedback** (REQUIRED)
For long operations, include progress indicators:

```python
def _download_progress_hook(self, count, block_size, total_size):
    """Progress callback for downloads."""
    if total_size > 0:
        percent = min(100, (count * block_size * 100) // total_size)
        mb_downloaded = (count * block_size) / (1024 * 1024)
        mb_total = total_size / (1024 * 1024)
        
        # Visual progress bar
        bar_length = 50
        filled_length = int(bar_length * percent // 100)
        bar = 'â–ˆ' * filled_length + 'â–‘' * (bar_length - filled_length)
        
        print(f'\rðŸ“¥ [{bar}] {percent}% ({mb_downloaded:.1f}/{mb_total:.1f} MB)', 
              end='', flush=True)
```

### 6. **Testing and Feedback** (REQUIRED)
Include immediate testing cells:
- Simple test cases with expected outputs
- Clear error messages for debugging
- Progressive complexity (simple â†’ complex)
- Visual verification where possible

## Educational Principles

1. **Build â†’ Use â†’ Understand â†’ Repeat**: Each module should follow this cycle
2. **Real Data, Real Systems**: Use production datasets, not synthetic data
3. **Immediate Feedback**: Students should see results quickly
4. **Visual Confirmation**: Students see their code working
5. **Systems Thinking**: Consider performance, caching, user experience
6. **Concrete Before Abstract**: Start with examples, then generalize
7. **Scaffolded Learning**: Provide hints and guidance, not just empty functions
8. **Standalone Modules**: Each module should be understandable independently
9. **Real-world Context**: Connect to practical ML applications

## Naming Convention

Module files should be named `{module_name}_dev.py` to indicate development notebooks, following the established pattern from [modules/setup/setup_dev.py](mdc:modules/setup/setup_dev.py) and [modules/tensor/tensor_dev.py](mdc:modules/tensor/tensor_dev.py).

## Quality Standards

All modules must:
- âœ… Use real data, not synthetic/mock data
- âœ… Include progress feedback for long operations
- âœ… Provide visual confirmation of working code
- âœ… Test with realistic data scales
- âœ… Follow "Build â†’ Use â†’ Understand" progression
- âœ… Include comprehensive TODO guidance with systems thinking
- âœ… Separate development richness from clean exports

## Naming Convention

Module files should be named `{module_name}_dev.py` to indicate development notebooks, following the established pattern from [modules/setup/setup_dev.py](mdc:modules/setup/setup_dev.py) and [modules/tensor/tensor_dev.py](mdc:modules/tensor/tensor_dev.py).
