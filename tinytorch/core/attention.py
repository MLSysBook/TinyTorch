# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘                        ğŸš¨ CRITICAL WARNING ğŸš¨                                â•‘
# â•‘                     AUTOGENERATED! DO NOT EDIT!                              â•‘
# â•‘                                                                               â•‘
# â•‘  This file is AUTOMATICALLY GENERATED from source modules.                   â•‘
# â•‘  ANY CHANGES MADE HERE WILL BE LOST when modules are re-exported!            â•‘
# â•‘                                                                               â•‘
# â•‘  âœ… TO EDIT: modules/source/07_attention/attention_dev.py           â•‘
# â•‘  âœ… TO EXPORT: Run 'tito module complete <module_name>'                      â•‘
# â•‘                                                                               â•‘
# â•‘  ğŸ›¡ï¸ STUDENT PROTECTION: This file contains optimized implementations.        â•‘
# â•‘     Editing it directly may break module functionality and training.         â•‘
# â•‘                                                                               â•‘
# â•‘  ğŸ“ LEARNING TIP: Work in modules/source/ - that's where real development    â•‘
# â•‘     happens! The tinytorch/ directory is just the compiled output.           â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# %% auto 0
__all__ = ['scaled_dot_product_attention', 'MultiHeadAttention']

# %% ../../modules/source/12_attention/attention_dev.ipynb 0
#| default_exp core.attention
#| export

# %% ../../modules/source/12_attention/attention_dev.ipynb 2
import numpy as np
import math
import time
from typing import Optional, Tuple, List

# Import dependencies from previous modules - following TinyTorch dependency chain
from .tensor import Tensor
from .layers import Linear

# %% ../../modules/source/12_attention/attention_dev.ipynb 6
def scaled_dot_product_attention(Q: Tensor, K: Tensor, V: Tensor, mask: Optional[Tensor] = None) -> Tuple[Tensor, Tensor]:
    """
    Compute scaled dot-product attention.

    This is the fundamental attention operation that powers all transformer models.
    We'll implement it with explicit loops first to show the O(nÂ²) complexity.

    TODO: Implement scaled dot-product attention step by step

    APPROACH:
    1. Extract dimensions and validate inputs
    2. Compute attention scores with explicit nested loops (show O(nÂ²) complexity)
    3. Scale by 1/âˆšd_k for numerical stability
    4. Apply causal mask if provided (set masked positions to -inf)
    5. Apply softmax to get attention weights
    6. Apply values with attention weights (another O(nÂ²) operation)
    7. Return output and attention weights

    Args:
        Q: Query tensor of shape (batch_size, seq_len, d_model)
        K: Key tensor of shape (batch_size, seq_len, d_model)
        V: Value tensor of shape (batch_size, seq_len, d_model)
        mask: Optional causal mask, True=allow, False=mask (batch_size, seq_len, seq_len)

    Returns:
        output: Attended values (batch_size, seq_len, d_model)
        attention_weights: Attention matrix (batch_size, seq_len, seq_len)

    EXAMPLE:
    >>> Q = Tensor(np.random.randn(2, 4, 64))  # batch=2, seq=4, dim=64
    >>> K = Tensor(np.random.randn(2, 4, 64))
    >>> V = Tensor(np.random.randn(2, 4, 64))
    >>> output, weights = scaled_dot_product_attention(Q, K, V)
    >>> print(output.shape)  # (2, 4, 64)
    >>> print(weights.shape)  # (2, 4, 4)
    >>> print(weights.data[0].sum(axis=1))  # Each row sums to ~1.0

    HINTS:
    - Use explicit nested loops to compute Q[i] @ K[j] for educational purposes
    - Scale factor is 1/âˆšd_k where d_k is the last dimension of Q
    - Masked positions should be set to -1e9 before softmax
    - Remember that softmax normalizes along the last dimension
    """
    ### BEGIN SOLUTION
    # Step 1: Extract dimensions and validate
    batch_size, seq_len, d_model = Q.shape
    assert K.shape == (batch_size, seq_len, d_model), f"K shape {K.shape} doesn't match Q shape {Q.shape}"
    assert V.shape == (batch_size, seq_len, d_model), f"V shape {V.shape} doesn't match Q shape {Q.shape}"

    # Step 2: Compute attention scores with explicit loops (educational O(nÂ²) demonstration)
    scores = np.zeros((batch_size, seq_len, seq_len))

    # Show the quadratic complexity explicitly
    for b in range(batch_size):           # For each batch
        for i in range(seq_len):          # For each query position
            for j in range(seq_len):      # Attend to each key position
                # Compute dot product between query i and key j
                score = 0.0
                for d in range(d_model):  # Dot product across embedding dimension
                    score += Q.data[b, i, d] * K.data[b, j, d]
                scores[b, i, j] = score

    # Step 3: Scale by 1/âˆšd_k for numerical stability
    scale_factor = 1.0 / math.sqrt(d_model)
    scores = scores * scale_factor

    # Step 4: Apply causal mask if provided
    if mask is not None:
        # mask[i,j] = False means position j should not attend to position i
        mask_value = -1e9  # Large negative value becomes 0 after softmax
        for b in range(batch_size):
            for i in range(seq_len):
                for j in range(seq_len):
                    if not mask.data[b, i, j]:  # If mask is False, block attention
                        scores[b, i, j] = mask_value

    # Step 5: Apply softmax to get attention weights (probability distribution)
    attention_weights = np.zeros_like(scores)
    for b in range(batch_size):
        for i in range(seq_len):
            # Softmax over the j dimension (what this query attends to)
            row = scores[b, i, :]
            max_val = np.max(row)  # Numerical stability
            exp_row = np.exp(row - max_val)
            sum_exp = np.sum(exp_row)
            attention_weights[b, i, :] = exp_row / sum_exp

    # Step 6: Apply attention weights to values (another O(nÂ²) operation)
    output = np.zeros((batch_size, seq_len, d_model))

    # Again, show the quadratic complexity
    for b in range(batch_size):           # For each batch
        for i in range(seq_len):          # For each output position
            for j in range(seq_len):      # Weighted sum over all value positions
                weight = attention_weights[b, i, j]
                for d in range(d_model):  # Accumulate across embedding dimension
                    output[b, i, d] += weight * V.data[b, j, d]

    return Tensor(output), Tensor(attention_weights)
    ### END SOLUTION

# %% ../../modules/source/12_attention/attention_dev.ipynb 10
class MultiHeadAttention:
    """
    Multi-head attention mechanism.

    Runs multiple attention heads in parallel, each learning different relationships.
    This is the core component of transformer architectures.
    """

    def __init__(self, embed_dim: int, num_heads: int):
        """
        Initialize multi-head attention.

        TODO: Set up linear projections and validate configuration

        APPROACH:
        1. Validate that embed_dim is divisible by num_heads
        2. Calculate head_dim (embed_dim // num_heads)
        3. Create linear layers for Q, K, V projections
        4. Create output projection layer
        5. Store configuration parameters

        Args:
            embed_dim: Embedding dimension (d_model)
            num_heads: Number of parallel attention heads

        EXAMPLE:
        >>> mha = MultiHeadAttention(embed_dim=512, num_heads=8)
        >>> mha.head_dim  # 64 (512 / 8)
        >>> len(mha.parameters())  # 4 linear layers * 2 params each = 8 tensors

        HINTS:
        - head_dim = embed_dim // num_heads must be integer
        - Need 4 Linear layers: q_proj, k_proj, v_proj, out_proj
        - Each projection maps embed_dim â†’ embed_dim
        """
        ### BEGIN SOLUTION
        assert embed_dim % num_heads == 0, f"embed_dim ({embed_dim}) must be divisible by num_heads ({num_heads})"

        self.embed_dim = embed_dim
        self.num_heads = num_heads
        self.head_dim = embed_dim // num_heads

        # Linear projections for queries, keys, values
        self.q_proj = Linear(embed_dim, embed_dim)
        self.k_proj = Linear(embed_dim, embed_dim)
        self.v_proj = Linear(embed_dim, embed_dim)

        # Output projection to mix information across heads
        self.out_proj = Linear(embed_dim, embed_dim)
        ### END SOLUTION

    def forward(self, x: Tensor, mask: Optional[Tensor] = None) -> Tensor:
        """
        Forward pass through multi-head attention.

        TODO: Implement the complete multi-head attention forward pass

        APPROACH:
        1. Extract input dimensions (batch_size, seq_len, embed_dim)
        2. Project input to Q, K, V using linear layers
        3. Reshape projections to separate heads: (batch, seq, heads, head_dim)
        4. Transpose to (batch, heads, seq, head_dim) for parallel processing
        5. Apply scaled dot-product attention to each head
        6. Transpose back and reshape to merge heads
        7. Apply output projection

        Args:
            x: Input tensor (batch_size, seq_len, embed_dim)
            mask: Optional attention mask (batch_size, seq_len, seq_len)

        Returns:
            output: Attended representation (batch_size, seq_len, embed_dim)

        EXAMPLE:
        >>> mha = MultiHeadAttention(embed_dim=64, num_heads=8)
        >>> x = Tensor(np.random.randn(2, 10, 64))  # batch=2, seq=10, dim=64
        >>> output = mha.forward(x)
        >>> print(output.shape)  # (2, 10, 64) - same as input

        HINTS:
        - Reshape: (batch, seq, embed_dim) â†’ (batch, seq, heads, head_dim)
        - Transpose: (batch, seq, heads, head_dim) â†’ (batch, heads, seq, head_dim)
        - After attention: reverse the process to merge heads
        - Use scaled_dot_product_attention for each head
        """
        ### BEGIN SOLUTION
        # Step 1: Extract dimensions
        batch_size, seq_len, embed_dim = x.shape
        assert embed_dim == self.embed_dim, f"Input dim {embed_dim} doesn't match expected {self.embed_dim}"

        # Step 2: Project to Q, K, V
        Q = self.q_proj.forward(x)  # (batch, seq, embed_dim)
        K = self.k_proj.forward(x)
        V = self.v_proj.forward(x)

        # Step 3: Reshape to separate heads
        # From (batch, seq, embed_dim) to (batch, seq, num_heads, head_dim)
        Q_heads = Q.data.reshape(batch_size, seq_len, self.num_heads, self.head_dim)
        K_heads = K.data.reshape(batch_size, seq_len, self.num_heads, self.head_dim)
        V_heads = V.data.reshape(batch_size, seq_len, self.num_heads, self.head_dim)

        # Step 4: Transpose to (batch, num_heads, seq, head_dim) for parallel processing
        Q_heads = np.transpose(Q_heads, (0, 2, 1, 3))
        K_heads = np.transpose(K_heads, (0, 2, 1, 3))
        V_heads = np.transpose(V_heads, (0, 2, 1, 3))

        # Step 5: Apply attention to each head
        head_outputs = []
        for h in range(self.num_heads):
            # Extract this head's Q, K, V
            Q_h = Tensor(Q_heads[:, h, :, :])  # (batch, seq, head_dim)
            K_h = Tensor(K_heads[:, h, :, :])
            V_h = Tensor(V_heads[:, h, :, :])

            # Apply attention for this head
            head_out, _ = scaled_dot_product_attention(Q_h, K_h, V_h, mask)
            head_outputs.append(head_out.data)

        # Step 6: Concatenate heads back together
        # Stack: list of (batch, seq, head_dim) â†’ (batch, num_heads, seq, head_dim)
        concat_heads = np.stack(head_outputs, axis=1)

        # Transpose back: (batch, num_heads, seq, head_dim) â†’ (batch, seq, num_heads, head_dim)
        concat_heads = np.transpose(concat_heads, (0, 2, 1, 3))

        # Reshape: (batch, seq, num_heads, head_dim) â†’ (batch, seq, embed_dim)
        concat_output = concat_heads.reshape(batch_size, seq_len, self.embed_dim)

        # Step 7: Apply output projection
        output = self.out_proj.forward(Tensor(concat_output))

        return output
        ### END SOLUTION

    def parameters(self) -> List[Tensor]:
        """
        Return all trainable parameters.

        TODO: Collect parameters from all linear layers

        APPROACH:
        1. Get parameters from q_proj, k_proj, v_proj, out_proj
        2. Combine into single list

        Returns:
            List of all parameter tensors
        """
        ### BEGIN SOLUTION
        params = []
        params.extend(self.q_proj.parameters())
        params.extend(self.k_proj.parameters())
        params.extend(self.v_proj.parameters())
        params.extend(self.out_proj.parameters())
        return params
        ### END SOLUTION
