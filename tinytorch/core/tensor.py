# AUTOGENERATED! DO NOT EDIT! File to edit: ../../modules/01_tensor/tensor_dev_enhanced.ipynb.

# %% auto 0
__all__ = ['Tensor']

# %% ../../modules/01_tensor/tensor_dev_enhanced.ipynb 2
import numpy as np
from typing import Union, List, Tuple, Optional

# %% ../../modules/01_tensor/tensor_dev_enhanced.ipynb 4
class Tensor:
    """
    TinyTorch Tensor: N-dimensional array with ML operations.
    
    This enhanced version demonstrates dual-purpose educational content
    suitable for both self-learning and formal assessment.
    """
    
    def __init__(self, data: Union[int, float, List, np.ndarray], dtype: Optional[str] = None):
        """
        Create a new tensor from data.
        
        Args:
            data: Input data (scalar, list, or numpy array)
            dtype: Data type ('float32', 'int32', etc.). Defaults to auto-detect.
        """
        #| exercise_start
        #| hint: Use np.array() to convert input data to numpy array
        #| solution_test: tensor.shape should match input shape
        #| difficulty: easy
        
        ### BEGIN SOLUTION
        # Convert input to numpy array
        if isinstance(data, (int, float)):
            self._data = np.array(data)
        elif isinstance(data, list):
            self._data = np.array(data)
        elif isinstance(data, np.ndarray):
            self._data = data.copy()
        else:
            self._data = np.array(data)
        
        # Apply dtype conversion if specified
        if dtype is not None:
            self._data = self._data.astype(dtype)
        ### END SOLUTION
        
        #| exercise_end
        
    @property
    def data(self) -> np.ndarray:
        """Access underlying numpy array."""
        #| exercise_start
        #| hint: Return the stored numpy array (_data attribute)
        #| solution_test: tensor.data should return numpy array
        #| difficulty: easy
        
        ### BEGIN SOLUTION
        return self._data
        ### END SOLUTION
        
        #| exercise_end
        
    @property
    def shape(self) -> Tuple[int, ...]:
        """Get tensor shape."""
        #| exercise_start
        #| hint: Use the .shape attribute of the numpy array
        #| solution_test: tensor.shape should return tuple of dimensions
        #| difficulty: easy
        
        ### BEGIN SOLUTION
        return self._data.shape
        ### END SOLUTION
        
        #| exercise_end
        
    @property
    def size(self) -> int:
        """Get total number of elements."""
        #| exercise_start
        #| hint: Use the .size attribute of the numpy array
        #| solution_test: tensor.size should return total element count
        #| difficulty: easy
        
        ### BEGIN SOLUTION
        return self._data.size
        ### END SOLUTION
        
        #| exercise_end
        
    @property
    def dtype(self) -> np.dtype:
        """Get data type as numpy dtype."""
        #| exercise_start
        #| hint: Use the .dtype attribute of the numpy array
        #| solution_test: tensor.dtype should return numpy dtype
        #| difficulty: easy
        
        ### BEGIN SOLUTION
        return self._data.dtype
        ### END SOLUTION
        
        #| exercise_end
        
    def __repr__(self) -> str:
        """String representation of the tensor."""
        #| exercise_start
        #| hint: Format as "Tensor([data], shape=shape, dtype=dtype)"
        #| solution_test: repr should include data, shape, and dtype
        #| difficulty: medium
        
        ### BEGIN SOLUTION
        data_str = self._data.tolist()
        return f"Tensor({data_str}, shape={self.shape}, dtype={self.dtype})"
        ### END SOLUTION
        
        #| exercise_end
        
    def add(self, other: 'Tensor') -> 'Tensor':
        """
        Add two tensors element-wise.
        
        Args:
            other: Another tensor to add
            
        Returns:
            New tensor with element-wise sum
        """
        #| exercise_start
        #| hint: Use numpy's + operator for element-wise addition
        #| solution_test: result should be new Tensor with correct values
        #| difficulty: medium
        
        ### BEGIN SOLUTION
        result_data = self._data + other._data
        return Tensor(result_data)
        ### END SOLUTION
        
        #| exercise_end
        
    def multiply(self, other: 'Tensor') -> 'Tensor':
        """
        Multiply two tensors element-wise.
        
        Args:
            other: Another tensor to multiply
            
        Returns:
            New tensor with element-wise product
        """
        #| exercise_start
        #| hint: Use numpy's * operator for element-wise multiplication
        #| solution_test: result should be new Tensor with correct values
        #| difficulty: medium
        
        ### BEGIN SOLUTION
        result_data = self._data * other._data
        return Tensor(result_data)
        ### END SOLUTION
        
        #| exercise_end
        
    def matmul(self, other: 'Tensor') -> 'Tensor':
        """
        Matrix multiplication of two tensors.
        
        Args:
            other: Another tensor for matrix multiplication
            
        Returns:
            New tensor with matrix product
            
        Raises:
            ValueError: If shapes are incompatible for matrix multiplication
        """
        #| exercise_start
        #| hint: Use np.dot() for matrix multiplication, check shapes first
        #| solution_test: result should handle shape validation and matrix multiplication
        #| difficulty: hard
        
        ### BEGIN SOLUTION
        # Check shape compatibility
        if len(self.shape) != 2 or len(other.shape) != 2:
            raise ValueError("Matrix multiplication requires 2D tensors")
        
        if self.shape[1] != other.shape[0]:
            raise ValueError(f"Cannot multiply shapes {self.shape} and {other.shape}")
        
        result_data = np.dot(self._data, other._data)
        return Tensor(result_data)
        ### END SOLUTION
        
        #| exercise_end
